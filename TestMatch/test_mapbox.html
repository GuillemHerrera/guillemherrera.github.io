<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Animate a line</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.51.0/mapbox-gl.js'></script>
    
    <script type="text/javascript" src="path.js"></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.51.0/mapbox-gl.css' rel='stylesheet' />

    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>

<style>
button {
    position: absolute;
    margin: 20px;
}

#pause::after {
    content: 'Pause';
}

#pause.pause::after {
    content: 'Play';
}
</style>
<div id='map'></div>
<button id='pause'></button>
<script>

function cheapRuler(lat /*: number */, units /*: ?string */) {
    return new CheapRuler(lat, units);
}

/**
 * Multipliers for converting between units.
 *
 * @example
 * // convert 50 meters to yards
 * 50 * cheapRuler.units.yards / cheapRuler.units.meters;
 */
var factors = cheapRuler.units = {
    kilometers: 1,
    miles: 1000 / 1609.344,
    nauticalmiles: 1000 / 1852,
    meters: 1000,
    metres: 1000,
    yards: 1000 / 0.9144,
    feet: 1000 / 0.3048,
    inches: 1000 / 0.0254
};

/**
 * Creates a ruler object from tile coordinates (y and z). Convenient in tile-reduce scripts.
 *
 * @param {number} y
 * @param {number} z
 * @param {string} [units='kilometers']
 * @returns {CheapRuler}
 * @example
 * var ruler = cheapRuler.fromTile(1567, 12);
 * //=ruler
 */
cheapRuler.fromTile = function (y, z, units) {
    var n = Math.PI * (1 - 2 * (y + 0.5) / Math.pow(2, z));
    var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))) * 180 / Math.PI;
    return new CheapRuler(lat, units);
};

function CheapRuler(lat, units) {
    if (lat === undefined) throw new Error('No latitude given.');
    if (units && !factors[units]) throw new Error('Unknown unit ' + units + '. Use one of: ' + Object.keys(factors).join(', '));

    var m = units ? factors[units] : 1;

    var cos = Math.cos(lat * Math.PI / 180);
    var cos2 = 2 * cos * cos - 1;
    var cos3 = 2 * cos * cos2 - cos;
    var cos4 = 2 * cos * cos3 - cos2;
    var cos5 = 2 * cos * cos4 - cos3;

    // multipliers for converting longitude and latitude degrees into distance (http://1.usa.gov/1Wb1bv7)
    this.kx = m * (111.41513 * cos - 0.09455 * cos3 + 0.00012 * cos5);
    this.ky = m * (111.13209 - 0.56605 * cos2 + 0.0012 * cos4);
}

CheapRuler.prototype = {
    /**
     * Given two points of the form [longitude, latitude], returns the distance.
     *
     * @param {Array<number>} a point [longitude, latitude]
     * @param {Array<number>} b point [longitude, latitude]
     * @returns {number} distance
     * @example
     * var distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
     * //=distance
     */
    distance: function (a, b) {
        var dx = (a[0] - b[0]) * this.kx;
        var dy = (a[1] - b[1]) * this.ky;
        return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the bearing between two points in angles.
     *
     * @param {Array<number>} a point [longitude, latitude]
     * @param {Array<number>} b point [longitude, latitude]
     * @returns {number} bearing
     * @example
     * var bearing = ruler.bearing([30.5, 50.5], [30.51, 50.49]);
     * //=bearing
     */
    bearing: function (a, b) {
        var dx = (b[0] - a[0]) * this.kx;
        var dy = (b[1] - a[1]) * this.ky;
        if (!dx && !dy) return 0;
        var bearing = Math.atan2(dx, dy) * 180 / Math.PI;
        if (bearing > 180) bearing -= 360;
        return bearing;
    },

    /**
     * Returns a new point given distance and bearing from the starting point.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} dist distance
     * @param {number} bearing
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.destination([30.5, 50.5], 0.1, 90);
     * //=point
     */
    destination: function (p, dist, bearing) {
        var a = bearing * Math.PI / 180;
        return this.offset(p,
            Math.sin(a) * dist,
            Math.cos(a) * dist);
    },

    /**
     * Returns a new point given easting and northing offsets (in ruler units) from the starting point.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} dx easting
     * @param {number} dy northing
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.offset([30.5, 50.5], 10, 10);
     * //=point
     */
    offset: function (p, dx, dy) {
        return [
            p[0] + dx / this.kx,
            p[1] + dy / this.ky
        ];
    },

    /**
     * Given a line (an array of points), returns the total line distance.
     *
     * @param {Array<Array<number>>} points [longitude, latitude]
     * @returns {number} total line distance
     * @example
     * var length = ruler.lineDistance([
     *     [-67.031, 50.458], [-67.031, 50.534],
     *     [-66.929, 50.534], [-66.929, 50.458]
     * ]);
     * //=length
     */
    lineDistance: function (points) {
        var total = 0;
        for (var i = 0; i < points.length - 1; i++) {
            total += this.distance(points[i], points[i + 1]);
        }
        return total;
    },

    /**
     * Given a polygon (an array of rings, where each ring is an array of points), returns the area.
     *
     * @param {Array<Array<Array<number>>>} polygon
     * @returns {number} area value in the specified units (square kilometers by default)
     * @example
     * var area = ruler.area([[
     *     [-67.031, 50.458], [-67.031, 50.534], [-66.929, 50.534],
     *     [-66.929, 50.458], [-67.031, 50.458]
     * ]]);
     * //=area
     */
    area: function (polygon) {
        var sum = 0;

        for (var i = 0; i < polygon.length; i++) {
            var ring = polygon[i];

            for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
                sum += (ring[j][0] - ring[k][0]) * (ring[j][1] + ring[k][1]) * (i ? -1 : 1);
            }
        }

        return (Math.abs(sum) / 2) * this.kx * this.ky;
    },

    /**
     * Returns the point at a specified distance along the line.
     *
     * @param {Array<Array<number>>} line
     * @param {number} dist distance
     * @returns {Array<number>} point [longitude, latitude]
     * @example
     * var point = ruler.along(line, 2.5);
     * //=point
     */
    along: function (line, dist) {
        var sum = 0;

        if (dist <= 0) return line[0];

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];
            var d = this.distance(p0, p1);
            sum += d;
            if (sum > dist) return interpolate(p0, p1, (dist - (sum - d)) / d);
        }

        return line[line.length - 1];
    },

    /**
     * Returns an object of the form {point, index, t}, where point is closest point on the line
     * from the given point, index is the start index of the segment with the closest point,
     * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
     *
     * @pointOnLine
     * @param {Array<Array<number>>} line
     * @param {Array<number>} p point [longitude, latitude]
     * @returns {Object} {point, index, t}
     * @example
     * var point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
     * //=point
     */
    pointOnLine: function (line, p) {
        var minDist = Infinity;
        var minX, minY, minI, minT;

        for (var i = 0; i < line.length - 1; i++) {

            var x = line[i][0];
            var y = line[i][1];
            var dx = (line[i + 1][0] - x) * this.kx;
            var dy = (line[i + 1][1] - y) * this.ky;

            if (dx !== 0 || dy !== 0) {

                var t = ((p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);

                if (t > 1) {
                    x = line[i + 1][0];
                    y = line[i + 1][1];

                } else if (t > 0) {
                    x += (dx / this.kx) * t;
                    y += (dy / this.ky) * t;
                }
            }

            dx = (p[0] - x) * this.kx;
            dy = (p[1] - y) * this.ky;

            var sqDist = dx * dx + dy * dy;
            if (sqDist < minDist) {
                minDist = sqDist;
                minX = x;
                minY = y;
                minI = i;
                minT = t;
            }
        }

        return {
            point: [minX, minY],
            index: minI,
            t: Math.max(0, Math.min(1, minT))
        };
    },

    /**
     * Returns a part of the given line between the start and the stop points (or their closest points on the line).
     *
     * @param {Array<number>} start point [longitude, latitude]
     * @param {Array<number>} stop point [longitude, latitude]
     * @param {Array<Array<number>>} line
     * @returns {Array<Array<number>>} line part of a line
     * @example
     * var line2 = ruler.lineSlice([-67.04, 50.5], [-67.05, 50.56], line1);
     * //=line2
     */
    lineSlice: function (start, stop, line) {
        var p1 = this.pointOnLine(line, start);
        var p2 = this.pointOnLine(line, stop);

        if (p1.index > p2.index || (p1.index === p2.index && p1.t > p2.t)) {
            var tmp = p1;
            p1 = p2;
            p2 = tmp;
        }

        var slice = [p1.point];

        var l = p1.index + 1;
        var r = p2.index;

        if (!equals(line[l], slice[0]) && l <= r)
            slice.push(line[l]);

        for (var i = l + 1; i <= r; i++) {
            slice.push(line[i]);
        }

        if (!equals(line[r], p2.point))
            slice.push(p2.point);

        return slice;
    },

    /**
     * Returns a part of the given line between the start and the stop points indicated by distance along the line.
     *
     * @param {number} start distance
     * @param {number} stop distance
     * @param {Array<Array<number>>} line
     * @returns {Array<Array<number>>} line part of a line
     * @example
     * var line2 = ruler.lineSliceAlong(10, 20, line1);
     * //=line2
     */
    lineSliceAlong: function (start, stop, line) {
        var sum = 0;
        var slice = [];

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];
            var d = this.distance(p0, p1);

            sum += d;

            if (sum > start && slice.length === 0) {
                slice.push(interpolate(p0, p1, (start - (sum - d)) / d));
            }

            if (sum >= stop) {
                slice.push(interpolate(p0, p1, (stop - (sum - d)) / d));
                return slice;
            }

            if (sum > start) slice.push(p1);
        }

        return slice;
    },

    /**
     * Given a point, returns a bounding box object ([w, s, e, n]) created from the given point buffered by a given distance.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {number} buffer
     * @returns {Array<number>} box object ([w, s, e, n])
     * @example
     * var bbox = ruler.bufferPoint([30.5, 50.5], 0.01);
     * //=bbox
     */
    bufferPoint: function (p, buffer) {
        var v = buffer / this.ky;
        var h = buffer / this.kx;
        return [
            p[0] - h,
            p[1] - v,
            p[0] + h,
            p[1] + v
        ];
    },

    /**
     * Given a bounding box, returns the box buffered by a given distance.
     *
     * @param {Array<number>} box object ([w, s, e, n])
     * @param {number} buffer
     * @returns {Array<number>} box object ([w, s, e, n])
     * @example
     * var bbox = ruler.bufferBBox([30.5, 50.5, 31, 51], 0.2);
     * //=bbox
     */
    bufferBBox: function (bbox, buffer) {
        var v = buffer / this.ky;
        var h = buffer / this.kx;
        return [
            bbox[0] - h,
            bbox[1] - v,
            bbox[2] + h,
            bbox[3] + v
        ];
    },

    /**
     * Returns true if the given point is inside in the given bounding box, otherwise false.
     *
     * @param {Array<number>} p point [longitude, latitude]
     * @param {Array<number>} box object ([w, s, e, n])
     * @returns {boolean}
     * @example
     * var inside = ruler.insideBBox([30.5, 50.5], [30, 50, 31, 51]);
     * //=inside
     */
    insideBBox: function (p, bbox) {
        return p[0] >= bbox[0] &&
               p[0] <= bbox[2] &&
               p[1] >= bbox[1] &&
               p[1] <= bbox[3];
    }
};

function equals(a, b) {
    return a[0] === b[0] && a[1] === b[1];
}

function interpolate(a, b, t) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return [
        a[0] + dx * t,
        a[1] + dy * t
    ];
}


//var path = [[2.49070173679741,41.6900696251289,1355552863,null],[2.49110045226993,41.6903599691828,1355552872,9],[2.49124809157941,41.6904674795907,1355552875,3],[2.49153069496556,41.6906732698469,1355552880,5],[2.4916384924246,41.6907517671996,1355552882,2],[2.49171324826757,41.6908062038233,1355552883.53896,1.53895783424377],[2.49184648401943,41.6908813610718,1355552886,2.46104216575623],[2.49192111842432,41.6909234617191,1355552888.07278,2.0727756023407],[2.4919244227803,41.6909883571083,1355552890,1.9272243976593],[2.49192561000074,41.6910116733248,1355552890.61464,0.614638328552246],[2.49193189820773,41.69113671223,1355552893.91073,3.29609394073486]];
//var path = [[2.49193189820773,41.69113671223,1355552893.91073,null],[2.49192363598702,41.6912157850112,1355552896,2.08926773071289],[2.49192363598702,41.6912157850112,1355552907,11],[2.49192363598702,41.6912157850112,1355552928,21],[2.49192363598702,41.6912157850112,1355552965,37],[2.49193189820773,41.69113671223,1355553006,41],[2.49193189820773,41.69113671223,1355553056,50],[2.49193189820773,41.69113671223,1355553094,38],[2.49193189820773,41.69113671223,1355553142,48],[2.49192426222033,41.6912097917095,1355553185,43],[2.49192426222033,41.6912097917095,1355553229,44],[2.49192426222033,41.6912097917095,1355553270,41],[2.49192426222033,41.6912097917095,1355553294,24],[2.49192426222033,41.6912097917095,1355553300,6],[2.49193189820773,41.69113671223,1355553300.7966,0.796602249145508],[2.49179233229922,41.6911741330062,1355553302,1.20339775085449],[2.49163370312157,41.6912166650495,1355553307,5],[2.49129166890474,41.6913083720051,1355553313.34381,6.34381008148193],[2.49130016703763,41.6913357157595,1355553314,0.656189918518066],[2.49133778579893,41.6914567584633,1355553319,5],[2.49151588839965,41.6920298210337,1355553331.45162,12.4516234397888],[2.49154667430921,41.6920178722681,1355553332,0.548376560211182],[2.49167976720788,41.6919662156288,1355553336,4],[2.49185221764203,41.6918992832967,1355553339.88044,3.88043904304504],[2.49185790509485,41.6919006827431,1355553340,0.119560956954956],[2.49196259800027,41.691926443323,1355553342,2],[2.49214228364727,41.6919706564807,1355553344.57735,2.57734966278076],[2.49285437817299,41.6921602914259,1355553354.87674,10.2993946075439],[2.49300004030029,41.6922016920366,1355553357,2.12325572967529],[2.49316780037562,41.692249373372,1355553359.19307,2.19306969642639],[2.4936963690888,41.6924076813454,1355553366.15097,6.95790100097656]];


var path_length = path.length;
var fin_time = path[path.length-1][2];
var init_time = path[0][2];
//console.log(path[0],path[1],[path[1][0],path[1][1]]);
console.log(init_time, fin_time, path_length);


// Create a GeoJSON source with an empty lineString.
var geojson = {
    "type": "FeatureCollection",
    "features": [{
        "type": "Feature",
        "geometry": {
            "type": "LineString",
            "coordinates": [
                
            ]
        }
    }]
};
var i_x=path[0][0];
var i_y=path[0][1];


geojson.features[0].geometry.coordinates.push([i_x, i_y]);

console.log([path[0][0], path[0][1]]);
console.log(geojson);

mapboxgl.accessToken = 'pk.eyJ1IjoiZ3VpbGxlbWhlcnJlcmEiLCJhIjoiY2pjamdtMjMyMjU3OTJ3cGEzOHk0eGt3MCJ9.37rBv4h8G6B33tiBCDhsow';
var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v10',
    center: [path[0][0], path[0][1]],
    zoom: 17
});

var speedFactor = 2000; // number of frames per longitude degree
var animation; // to store and cancel the animation
var startTime = 0;
var progress = 0; // progress = timestamp - startTime
var resetTime = false; // indicator of whether time reset is needed for the animation
var pauseButton = document.getElementById('pause');

var ruler = cheapRuler(path[0][1], 'meters');
//console.log(ruler);
map.on('load', function() {

    // add the line which will be modified in the animation
    map.addLayer({
        'id': 'line-animation',
        'type': 'line',
        'source': {
            'type': 'geojson',
            'data': geojson
        },
        'layout': {
            'line-cap': 'round',
            'line-join': 'round'
        },
        'paint': {
            'line-color': '#ed6498',
            'line-width': 5,
            'line-opacity': .8
        },
        "filter": ["==", "$type", "LineString"]
    });

    startTime = performance.now();

    //animateLine();

    // click the button to pause or play
    pauseButton.addEventListener('click', function() {
        pauseButton.classList.toggle('pause');
        if (pauseButton.classList.contains('pause')) {
            cancelAnimationFrame(animation);
            console.log(geojson);
        } else {
            resetTime = true;
            animateLine();
        }
    });

    // reset startTime and progress once the tab loses or gains focus
    // requestAnimationFrame also pauses on hidden tabs by default
    document.addEventListener('visibilitychange', function() {
        resetTime = true;
    });

    
    // variables to compute movement
    i = 1;
    var line = [
                [path[i-1][0],path[i-1][1]], 
                [path[i][0],path[i][1]]
                ];
    var length = ruler.lineDistance(line);
    var el_time = path[i][3];
    //console.log(el_time);
    var vel = length / el_time;
    var c_pos;
    var x;
    var y;
    var x_y;
    var speed_fac = 200;
    console.log(length, el_time, vel );

                
    // animated in a circle as a sine wave along the map.
    function animateLine(timestamp) {
        if (resetTime) {
            // resume previous progress
            startTime = performance.now() - progress;
            resetTime = false;
        } else {
            progress = timestamp - startTime;
        }

        // restart if it finishes a loop
        //if (progress > speedFactor * 360) {
        //    startTime = timestamp;
        //    geojson.features[0].geometry.coordinates = [];
        //} else {


        //if (c_pos/length >= 1) {
        if (((progress/1000)*speed_fac) >= el_time){ 
            if ((i+1) < path_length){

                // reacreating previous feature -simplifiing
                geojson.features[i-1].geometry.coordinates = line;
                //appending feature

                feature = {};
                feature['type'] = 'Feature';
                feature['geometry'] = {'type': 'LineString',
                                       'coordinates': [[path[i][0],path[i][1]]]
                                       };
                geojson['features'].push(feature);
                
                i +=1;
                line = [
                    [path[i-1][0],path[i-1][1]], 
                    [path[i][0],path[i][1]]
                    ];
                length = ruler.lineDistance(line);

                //reset time for segment
                startTime = performance.now();
                progress = timestamp - startTime;
                
                el_time = path[i][3];

                if (length == 0) {
                    //continue;
                   // animation = requestAnimationFrame(animateLine);
                   console.log("stop - elapsed time" + el_time + 's');
                   geojson.features[i-1].geometry.type = 'Point'
                   geojson.features[i-1].geometry.coordinates = [path[i][0],path[i][1]];
                } else {
                    vel = length / el_time;
                    
                    c_pos = vel * ((progress/(1000)*speed_fac));
                    x_y = ruler.along(line, c_pos);
                    x = x_y[0];
                    y = x_y[1];
                    geojson.features[i-1].geometry.coordinates.push([x, y]);
                    // then update the map
                    map.getSource('line-animation').setData(geojson);

                    console.log(length, el_time, vel );
                }
            } else  {
              return false;  
            } 
        } else {   
            
            if (length == 0) {}
            else { 
                c_pos = vel * ((progress/(1000)*speed_fac));
                x_y = ruler.along(line, c_pos);
                x = x_y[0];
                y = x_y[1];
                //console.log(x,y);
                // draw a sine wave with some math.
                //var y = Math.sin(x * Math.PI / 90) * 40;
                // append new coordinates to the lineString
                geojson.features[i-1].geometry.coordinates.push([x, y]);
                // then update the map
                map.getSource('line-animation').setData(geojson);
            }
        } 
        //}
        // Request the next frame of the animation.
        animation = requestAnimationFrame(animateLine);
    }
});
</script>

</body>
</html>